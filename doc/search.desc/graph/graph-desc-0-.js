searchState.loadedDescShard("graph", 0, "How can a <code>Road</code> be crossed by a particular <code>Mode</code>?\nA study area imported from OpenStreetMap.\nAn intersection between one or more roads. This might …\nThe graph structure is expressed for each of these …\nA single step along a route\nA position along a road, along with the closest …\nRepresents an edge going between exactly two <code>Intersection</code>s.\nA route between two positions.\nManages routing queries for one mode. This structure uses …\nPer mode, what direction is this road traversable?\nCan this mode cross this road in the backwards direction?\nCan this mode cross this road in the forwards direction?\nA polygon covering the study area.\nCreate a router allowing every road in both directions, …\nFind the Road going from <code>i1</code> to <code>i2</code> or vice versa\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFrom a list of start intersections, floods out the graph …\nReturn a polygon covering the world, minus a hole for the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRenders a route as a linestring (in Mercator), with …\nFor cars, the speed limit in meters/second\n<code>Graph</code> stores all geometry in a Mercator projection for the …\nCreates a router for a mode. This is slow to calculate, as …\nConstructs a graph from OpenStreetMap data.\nTakes a path to a GTFS directory. If no Mercator is …\nParses a string. Treats “transit” as Mode::Foot\nStop a nested step\nStart a new step with nested steps following it\nReturns GeoJSON with roads and stops\nCalculates a route between two positions.\nGiven an input LineString (in Mercator), try to …\nGiven a point (in Mercator) and mode, snap to a position …\nStart a new step, with no nesting\nThe bus stops associated with this road\nStarting from a stop at some time, find all the next trips …")